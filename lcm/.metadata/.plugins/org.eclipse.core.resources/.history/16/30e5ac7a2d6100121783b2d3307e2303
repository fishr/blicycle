/**
 * Blicycle Computer Vision Module
 *
 * This module allows the blicycle to navigate.
 * Its job is to estimate the position of the bicycle
 * with respect to the track using computer vision.
 * Our approach is to follow the grass-track border
 * along the inner edge of the track.
 *
 * This module outputs a stream of data in the form
 * of (deltaX, deltaTheta, stable) to the blicycle controller
 * (which runs as a separate process). The blicycle
 * controller than uses this information to steer
 * the blicycle on course.
 *
 * Code written by Steve Levine, sjlevine@mit.edu
 * and released under the MIT license.
 */

#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <math.h>
#include "opencv/cv.h"
#include "opencv/highgui.h"
#include "lcm/lcm.h"
//#include "bot_core/bot_core.h"
#include "lcmtypes/bot_core.h"


// Global variables
bot_core_image_t bot_image;


using namespace std;
using namespace cv;
typedef struct _Comp {
  lcm_t* subscribe_lcm;
  lcm_t* publish_lcm;
  int counter;
}Comp;



// Print help information
void print_help() {
    printf("** Invalid syntax!\n"
           "   Usage: blicycle <capture/videofile/imagefile> <source>\n"
           "       Capture: Use a live video stream. In\n"
           "           this case source is the camera #.\n\n"
           "       VideoFile: Read in an (AVI) file. In this\n"
           "            case data is a filename.\n"
	   "       ImageFile: Read in an image file, and process\n"
	   "             it (not a video).\n");
}


int main( int argc, char** argv ) {

	// Print a welcome message
	printf("Blicycle CV v1.0\n");

	// Based on the command line arguments to this executable, capture either from
	// a data file or from a live video stream
	if (argc != 3) {
		print_help();
		exit(1);
	}

	CvCapture* capture;
	IplImage* image = NULL;

	if (!strcasecmp(argv[1], "CAPTURE")) {
		// Capture live video
		int video_source = atoi(argv[2]);
		capture = cvCaptureFromCAM(video_source);
		if (!capture) {
			printf("Couldn't capture video!\n");
		}


	} else if (!strcasecmp(argv[1], "VIDEOFILE")) {
		// Play from a file
		printf("   Mode: File playback\n   File: %s\n\n", argv[2]);
		capture = cvCaptureFromFile(argv[2]);
		if (!capture) {
			printf("Invalid video file name!\n");
			exit(1);
		}

	} else if (!strcasecmp(argv[1], "IMAGEFILE")) {
		// Play from a file
		printf("   Mode: Image process\n   File: %s\n\n", argv[2]);
		image = cvLoadImage(argv[2], CV_LOAD_IMAGE_COLOR);
		if (!image) {
			printf("Invalid image file name!\n");
			exit(1);
		}
		// Convert to the HSV color space
		//cvCvtColor(image, image, CV_RGB2BGR);


	} else {
		// Invalid
		print_help();
		exit(1);
	}

	//Set Up LCM

	Comp *self = (Comp*) calloc (1, sizeof (Comp));
	  self->publish_lcm=lcm_create(NULL);
	  //self->subscribe_lcm = lcm_create(NULL);
	  self->counter =0;


	//printf("   Capturing at:\n      Width: %d\n      Height:%d\n", width, height);


	while(1) {
		IplImage* frame;
		if (!image) {
			frame = cvQueryFrame(capture);
			if( !frame ) break;
		} else {
			frame = image;
		}


		bot_image->width = frame->width;
		bot_image->height = frame->height;
		bot_image->row_stride = frame->nChannels;
		bot_image->pixelformat = BOT_CORE_IMAGE_T_PIXEL_FORMAT_RGB;
		bot_image->data = (uchar*)(frame->imageData);


		// Send over the data!
		bot_core_image_t_publish(self->publish_lcm,"TESTIMAGE", &bot_image);


		if (!image) {
			char c = cvWaitKey(33);
			if( c == 27 ) break;
		} else {
			char c = cvWaitKey(0);
			break;
		}
	}
	cvReleaseCapture(&capture);

}
